<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<TITLE>EXIM OVERVIEW</TITLE>
<META NAME="generator" CONTENT="txt2html v1.21">
</HEAD>
<BODY bgcolor="#ccccff">
<H1>EXIM OVERVIEW</H1>


<P>
Date: 29 November 1996

<P>
Exim is a mail transport agent (MTA) developed at the University of Cambridge
for use on Unix systems connected to the Internet. It is freely available
under the terms of the GNU General Public Licence. In style it is similar to
Smail 3, but its facilities are more extensive, and in particular it has some
defences against mail bombs and unsolicited junk mail, in the form of options
for refusing messages from particular hosts, networks, or senders.

<P>
Exim is in production use on a number of sites that move tens of thousands of
messages per day. This document contains an overview description of the way
Exim works, with a certain amount of simplification to keep it fairly short.

<P>
This document is copyright (c) University of Cambridge 1996, but copying
permission is granted to all.
<HR>


<P>
    "If I have seen further it is by standing on the shoulders of giants."
<BR>
                                                                (Isaac Newton)
<HR>


<H2> Background</H2>

<P>
Exim owes a great deal to Smail 3 and its author, Ron Karr. Without the
experience of running and working on the Smail 3 code, I could never have
contemplated starting to write a new mailer. Many of the ideas and user
interfaces are taken from Smail 3, though the actual code of Exim is entirely
new.

<P>
My intention was to write a mailer that had more functionality than Smail 3,
but which retained the simple lightweight approach, as this seemed to me to be
all that was needed for systems directly connected to the Internet, where most
messages are delivered almost immediately.


<A NAME="0"><H2>2. Availability</H2></A>

<P>
The current distribution of Exim is available from

<P>
ftp://ftp.cus.cam.ac.uk/pub/software/programs/exim/exim-n.nn.tar.gz

<P>
where n.nn is the version number. The distribution contains an ASCII copy of
the documentation; other formats are available from

<P>
ftp://ftp.cus.cam.ac.uk/pub/software/programs/exim/exim-postscript-n.nn.tar.gz
ftp://ftp.cus.cam.ac.uk/pub/software/programs/exim/exim-texinfo-n.nn.tar.gz

<P>
The following operating systems are currently supported: AIX, BSDI, FreeBSD,
HP-UX, IRIX, Linux, NetBSD, DEC OSF1 (aka Digital UNIX), SCO, SunOS4, SunOS5,
and Ultrix.


<A NAME="1"><H2>3. Limitations</H2></A>

<P>
For the benefit of those reading this overview to see whether Exim is of
interest to them, its limitations are listed first.

<UL>
  <LI> Exim is written in ANSI C. This should not be much of a limitation these
     days. However, to help with systems that lack a true ANSI C library, Exim
     avoids making any use of the value returned by the sprintf() function,
     which is one of the main incompatibilities. It has its own version of
     strerror() for use with SunOS4 and any other system that lacks this
     function, and a macro can be defined to turn memmove() into bcopy() if
     necessary.

  <LI> Exim uses file names that are longer than 14 characters.

  <LI> Exim is intended for use as an Internet mailer, and therefore handles
     addresses in RFC 822 domain format only. It cannot handle 'bang paths',
     though simple two-component bang paths can be converted by a straightforward
     rewriting configuration.

  <LI> Exim insists that every address it handles has a domain attached. For
     incoming local messages, domainless addresses are automatically qualified
     with a configured domain value. Configuration options specify from which
     remote systems unqualified addresses are acceptable.

  <LI> The only external transport currently implemented is an SMTP transport
     over a TCP/IP network (using sockets), suitable for machines on the
     Internet. However, a pipe transport is available, and there are facilities
     for writing messages to files in 'batched SMTP' format; this can be
     used to send messages to some other transport mechanism. Batched SMTP
     input is also catered for.
</UL>


<A NAME="2"><H2>4. Main features</H2></A>

<P>
Exim follows the same general approach of decentralised control that Smail 3
does. There is no central process doing overall management of mail delivery.
However, unlike Smail, the independent delivery processes share data in the
form of 'hints', which makes delivery more efficient in some cases. The hints
are kept in a number of DBM files. If any of these files are lost, the only
effect is to change the pattern of delivery attempts and retries.

<P>
Here is a summary of Exim's main features. More details are given in the
sections which follow.

<UL>
  <LI> Many configuration options can be given as expansion strings, and as
     these can include file lookups, much of Exim's operation can be made
     table-driven if desired. For example, it is possible to do local delivery
     on a machine on which the users do not have accounts.

  <LI> Regular expressions are available in a number of configuration
     parameters.

  <LI> Domain lists can include file lookups, making it possible to support a
     large number of local domains.

  <LI> Exim has flexible retry algorithms, applicable to mail routing as well as
     to delivery.

  <LI> Exim contains header and envelope rewriting facilities.

  <LI> Unqualified addresses are accepted only from specified hosts or networks.

  <LI> Exim can perform multiple deliveries down the same SMTP channel after
     deliveries to a host have been delayed.

  <LI> Exim can be configured to do local deliveries immediately but to leave
     remote deliveries until the message is picked up by a queue-runner
     process. This increases the likelihood of multiple messages being sent
     down a single SMTP connection.

  <LI> When copies of a message have to be delivered to more than one remote
     host, up to a configured maximum number of remote deliveries can be done
     in parallel.

  <LI> Exim supports optional checking of incoming return path (sender) and
     receiver addresses as they are received by SMTP.

  <LI> SMTP calls from specific machines, optionally from specific idents, can
     be locked out, and incoming SMTP messages from specific senders can also
     be locked out.

  <LI> It is possible to control which hosts may use the Exim host as a relay
     for onward transmission of mail; the control can be made to depend on the
     address domain.

  <LI> Messages on the queue can be 'frozen' and 'thawed' by the administrator.

  <LI> The maximum size of message can be specified.

  <LI> Exim can handle a number of independent local domains on the same
     machine; each domain can have its own alias files, etc. These are
     commonly called "virtual domains".

  <LI> Exim stats a user's home directory before looking for a .forward file, in
     order to detect the case of a missing NFS mount.

  <LI> Exim contains an optional built-in mail filtering facility. This enables
     users to set up their own mail filtering in a straightforward manner
     without the need to run an external program. There can also be a system
     filter file that applies to all messages.

  <LI> There is support for multiple user mailboxes controlled by prefixes or
     suffixes on the user name, either via the filter mechanism or through
     multiple .forward files.

  <LI> Periodic warnings are automatically sent to messages' senders when
     delivery is delayed - the time between warnings is configurable.

  <LI> A queue run can be manually started to deliver just a particular portion
     of the queue, or those messages with a recipient whose address contains a
     given string.

  <LI> Exim can be configured to run as root all the time, except when
     performing local deliveries, which it always does in a separate process
     under an appropriate uid and gid. Alternatively, it can be configured to
     run as root only when needed; in particular, it need not run as root when
     receiving incoming messages or when sending out messages over SMTP.

  <LI> I have tried to make the wording of delivery failure messages clearer and
     simpler, for the benefit of those less-experienced people who are now
     using email.

  <LI> The Exim Monitor is an optional extra; it displays information about
     Exim's processing in an X window, and an administrator can perform a
     number of control actions from the window interface.
</UL>


<A NAME="3"><H2>5. Performance</H2></A>

<P>
Although I did not specifically set out to write a high-performance MTA, Exim
does seem to be fairly efficient. The busiest site I know of is an ISP that
handles over 40,000 messages a day on a Sun Ultra box. Our central mail
service machine in Cambridge (a SPARCstation-20) handles over 30,000 messages
on a typical day, the volume being around 130 megabytes on the day I looked.
The largest number of messages delivered in any one hour was 2753.

<P>
A system of a different character is sunsite.doc.ic.ac.uk, a SPARCserver 1000
system with 8 cpus, which is unusual in that virtually all mail deliveries are
remote and relatively large, because it is a data archive that can deliver
copies of its holdings via an email interface. On a fairly busy day 14,014
messages were received from 231 different hosts and 12,534 deliveries were
made to 468 different hosts. The total amount of outgoing mail was 431
megabytes. The largest number of deliveries in any one hour was 787.


<A NAME="4"><H2>6. Interface</H2></A>

<P>
Like many MTAs, Exim has adopted the Sendmail interface so that it can be a
straight replacement for /usr/lib/sendmail. All the relevant Sendmail options
are implemented. There are also some additional options that are compatible
with Smail 3, and some further options that are new to Exim.

<P>
The runtime configuration interface is a single file which is divided into a
number of sections. The entries in this file consist of keywords and values,
in the style of Smail 3 configuration files.

<P>
Control of messages on the queue can be done via certain privileged command
line options. There is also an optional monitor program called eximon, which
displays current information in an X window and contains interfaces to the
command line options.


<A NAME="5"><H2>7. Method of operation</H2></A>

<P>
When Exim receives a message, it writes two files in its spool directory. The
first contains the envelope information, the current status of the message,
and the headers, while the second contains the body of the message. The status
of the message includes a complete list of recipients and a list of those that
have already received the message. The header file gets updated during the
course of delivery if necessary.

<P>
A message remains in the spool directory until it is completely delivered to
its recipients or to an error address, or until it is deleted by an
administrator or by the user who originally created it. In cases when delivery
cannot proceed - for example, when a message can neither be delivered to its
recipients nor returned to its sender, the message is marked 'frozen' on the
spool, and no more deliveries are attempted. The administrator can thaw such
messages when the problem has been corrected, and can also freeze individual
messages by hand if necessary.

<P>
As delivery proceeds, Exim writes timestamped information about each address
to a per-message log file; this includes any delivery error messages. This log
is solely for the benefit of the administrator. All the information Exim
itself needs for delivery is kept in the header spool file. The message log
file is deleted with the spool files. If a message is delayed for more than a
configured time, a warning message is sent to the sender. This is repeated
whenever the same time elapses again without delivery being complete.

<P>
The main delivery processing elements of Exim are called directors, routers,
and transports. Code for a number of these is provided, and compile-time
options specify which ones are actually included in the binary. Directors
handle addresses that include one of the local domains, routers handle remote
addresses, and transports do actual deliveries.

<P>
When a message is to be delivered, the sequence of events is roughly as
follows:

<UL>
  <LI> If there is a system filter file, it is obeyed. This can check on the
     contents of the message and its headers, and cause delivery to be
     abandoned or directed to alternative or additional addresses.

  <LI> Each address is parsed and a check is made to see if it is local or not,
     by comparing the domain with the list of local domains, which can be
     wildcarded, or even held in a file if there are a large number of them.

  <LI> If an address is local, it is passed to each configured director in turn
     until one is able to handle it. If none can, the address is failed.
     Directors can be targeted at particular local domains, so several local
     domains can be processed independently of each other.

  <LI> A director that accepts an address may set up a local or a remote
     transport for it, or it may generate one or more new addresses (typically
     from alias or forward files). New addresses are fed back into this
     process from the top, but in order to avoid loops, a director will ignore
     any address which has an identically-named ancestor that was processed by
     itself.

  <LI> If an address is not local, it is passed to each router in turn until one
     is able to handle it. If none can, the address is failed.

  <LI> A router that accepts an address may set up a transport for it, or may
     pass an altered address to subsequent routers, or it may discover that
     the address is a local address after all. This typically happens when an
     partial domain name is used and (for example) the DNS lookup is
     configured to try to extend such names. In this case, the address is
     passed back to the directors.

  <LI> Routers normally set up remote transports for messages that are to be
     delivered to other machines. However, a router can pass a message to a
     local transport, and by this means messages can be routed to other
     transport mechanisms.

  <LI> When all the directing and routing is done, addresses that have been
     successfully handled are passed to their assigned transports. Local
     transports handle only one address at a time, but remote ones can handle
     more than one. Each local transport runs in a separate process under a
     non-privileged uid.

  <LI> If there were any errors, a message is returned to an appropriate address
     (the sender in the common case).

  <LI> If one or more addresses suffered a temporary failure, the message is
     left on the queue, to be tried again later. Otherwise the spool files and
     message log are deleted.
</UL>


<A NAME="6"><H2>8. Mail filtering</H2></A>

<P>
Exim can be configured to allow users to set up filter files as an alternative
to the traditional .forward files. A filter file can test various characteristics
of a message, including the contents of the headers and the start of
the body, and direct delivery to specified addresses, files, or pipes
according to what it finds. The system-wide filter file uses the same control
syntax.


<A NAME="7"><H2>9. Directors</H2></A>

<P>
The existing directors are listed below. I use the RFC 822 term local-part to
mean that portion of an address that comes before the @ character.

<UL>
  <LI> aliasfile: This director handles local-part expansion via a traditional
     alias file. The name of the file is obtained by string expansion, and may
     therefore depend on the local-part or the domain. Generated pipe and file
     addresses can be (independently) locked out.

</UL>
<P>
     The aliasfile director can also be used to test a list of local parts and
     direct any messages for them to a specific transport. In this case the
     data associated with the local part in the file is not used for address
     expansion, but is available for other purposes. For example, files
     containing records of the form

<P>
       foo: uid=1234 gid=5678 mailbox=/home_1/foo/inbox

<P>
     could be used on a system that did local deliveries without consulting
     its passwd file. The aliasfile director could use the file to verify that
     the local part was valid, and then the appendfile transport could use it
     to get a uid, gid, and mailbox for the delivery.

<UL>
  <LI> forwardfile: This director handles local-part expansion via a traditional
     forward file or, if so configured, by a user's filter file. The name of
     the file is obtained by string expansion, and may therefore depend on the
     local-part or the domain, though if it is not an absolute path it is
     automatically assumed to be in the home directory of the user whose login
     name is the local-part. Mailing lists can be handled by file names of the
     form

</UL>
<P>
       /some/list/directory/${local_part}

<P>
     and it is possible to specify an error address for each list that depends
     on the list name. Generated pipe and file addresses can be (independently)
     locked out.

<UL>
  <LI> localuser: This director matches the local-part of an address to a user
     of the machine. It can also be configured to do a pattern match on the
     user's home directory name. This makes it possible to partition the set
     of local users according to their home directories.

  <LI> smartuser: This director matches any local-part. It can be used to pass
     messages for unknown users to a script that generates a helpful error
     message, or it can be used to send such messages to another host,
     optionally changing the envelope address in the process.

</UL>
<P>
The configuration file determines which directors are actually used, and in
which order. It is possible to use the same director more than once, with
different options.

<P>
The addresses a director handles can be constrained in the following ways:

<UL>
  <LI> A specific set of local domains may be specified, in which case the
     director is called only for addresses that contain one of those domains.

  <LI> A specific set of local parts may be specified, in which case the
     director is called only for addresses that contain one of those local
     parts. This could be used, for example, to handle 'postmaster' independently
     of the particular local domain.

  <LI> A director may be configured to handle local-parts that start with a
     certain prefix and/or end with a certain suffix. For example, a director
     can be set up to handle local-parts of the form xxxx-request only.

  <LI> A flag controls whether a director is called when an address is being
     verified, as opposed to being directed for delivery.

</UL>
<P>
In addition, certain files can be required to exist or not exist for a given
director to be run.


<A NAME="8"><H2>10. Routers</H2></A>

<P>
The existing routers are:

<UL>
  <LI> domainlist: This director searches a list of domains for the one it is
     trying to route. The list may either be a string in the configuration
     file, possibly including wild cards or regular expressions, or it may be
     in a file, or both may be provided. In the case of a file, keys of the
     form *.foo.bar.com can be used for simple wildcarding.

</UL>
<P>
     If the domain is found, its entry can either specify a single replacement
     domain name that is passed on to subsequent routers, or it can specify a
     list of domain names that are looked up by this router. The lookup can be
     done by the gethostbyname function, or by DNS lookup, and in the latter
     case it is configurable whether MX or A records or both are used. As well
     as providing explicit routing for certain domains, the domainlist router
     can be used to set up gateways for partial domains (e.g. for *.uucp) and
     it can also be used as a 'smarthost' router by using the all-inclusive
     wild card.

<UL>
  <LI> lookuphost: This router looks up domain names either by calling the
     gethostbyname function, or by using the DNS. In the latter case, it can
     be configured to use the DNS resolver options for qualifying singlecomponent
     names and for searching parent domains. It is also possible to
     specify explicit text strings for widening domains that are not found
     initially. It is possible to insist on the presence of MX records for
     certain sets of domains. A configuration option controls whether the
     message's headers are rewritten when a domain name is changed.

  <LI> queryprogram: This router passes the address to a script that runs in a
     separate process under an unprivileged uid and gid. The script returns a
     line of text specifying whether it matched the domain or not. If it did
     match, it may specify a transport name, or it may specify that the
     transport specified for the router is used. The script may also send back
     a new domain name to replace the current one, and specify a method of
     looking this name up (gethostbyname, DNS, or pass to next router).

</UL>
<P>
The configuration file determines which routers are actually used, and in
which order. It is possible to use the same router more than once, with
different options.

<P>
Like directors, routers can be constrained to handle only certain domains or
certain local parts (though I haven't seen a good use for that yet). If a
router times out, either the delivery can be deferred, or the address can be
passed on to the next router.

<P>
A flag controls whether a router is called when an address is being verified,
as opposed to being routed for delivery.


<A NAME="9"><H2>11. Transports</H2></A>

<P>
Local and remote transports are handled differently. A local transport is
always run in a separate process with an appropriate real uid and gid. Their
values can be specified in the transport's configuration, or passed over from
the director that handled the address. The existing transports are:

<UL>
  <LI> appendfile: This local transport appends the message to a file whose name
     is specified as a string containing variable expansions. The current
     local-part can be inserted via the expansion mechanism, and file names
     such as

</UL>
<P>
     /home/${local_part}/inbox<BR>
     /var/mail/${local_part}

<P>
     are typical examples. However, it is possible to look up each individual
     user's inbox name in a file, should that be required.

<P>
     Exclusive access to the file is ensured by using the traditional mailbox
     locking strategy of creating a lock file. The lock creation process uses
     a 'hitching post' algorithm (similar to that used by Pine) which is
     robust when the mailbox file is NFS-mounted. The file is also locked
     using the lockf function.

<P>
     Options on this transport allow for the insertion of a prefix line (e.g.
     'From xxx...') and suffix line, special processing of message lines
     starting with 'From', and the addition of Return-path, Delivery-date, and
     Envelope-to headers. If the mailbox file is not a regular file, or does
     not have the correct owner, group, or permissions, no delivery takes
     place; the address is deferred and the postmaster is informed, except
     that, if the file's permissions are greater than those required, Exim
     reduces the permissions and carries on. There are additional checks to
     reduce the possibility of security exposures caused by race conditions.

<UL>
  <LI> pipe: This local transport passes the message via a pipe to a specified
     command (program or script) which is run in a separate process under a
     given uid and gid. Various parameters of the message are passed as
     environment variables, and there are the same options as for appendfile
     for controlling the form of the message.

</UL>
<P>
     The returned status of the command may be used to determine success or
     failure, or it can be ignored. A configuration option specifies whether
     any standard output generated by the transport is to be returned to the
     sender. If this is set and output is actually generated, the delivery is
     deemed to have failed, whatever the returned status of the command. The
     maximum amount of output generated by the command can be controlled, and
     a timeout may be set for it.

<UL>
  <LI> smtp: This remote transport delivers a message using SMTP over TCP/IP.
     All addresses in the message that route to the same set of hosts, and
     have the same errors address (return path), are normally sent in a single
     transaction. An explicit list of hosts can be set for the transport, or a
     host list may be attached to an address by one of the routers. If all the
     hosts are temporarily unable to accept the message, it is delivered to
     one of a list of fallback hosts, if configured.
</UL>


<A NAME="10"><H2>12. Exim logs</H2></A>

<P>
Exim write four different log files:

<UL>
  <LI> The main log records the arrival of each message and the result of each
     delivery attempt in a single line in each case. The format is as compact
     as possible, in an attempt to keep down the size of log files. A number
     of other events are also recorded on the main log.

  <LI> The reject log records information from messages that are rejected
     because their return paths are invalid (a configurable option). The
     headers are written to this log, following a copy of the one-line message
     that is also written to the main log. Other types of message rejection
     also cause writing to this log.

  <LI> The panic log is written when Exim suffers a disaster and has to bomb
     out.

  <LI> On systems that support signal handlers that restart a system call on
     exit, Exim reacts to a USR1 signal by writing a line describing its
     current activity to the process log. This makes it possible to find out
     what each exim process on a machine is currently doing.

</UL>
<P>
A utility script for renaming and compressing the main and reject logs each
night is provided. There are also scripts for extracting statistics from log
files and for searching log files for the entries for messages that match a
given pattern. For example, one can pull out all entries relating to messages
for a given local part.


<A NAME="11"><H2>13. Exim databases</H2></A>

<P>
Exim maintains a number of databases in DBM files to help it perform efficient
mail delivery. In effect, the files contain hints, and if they are lost it is
not a disaster - Exim's performance just suffers a bit. The three databases
currently used are:

<UL>
  <LI> retry: This contains information about each failing remote host and
     temporary failing local delivery - when the first failure was detected,
     when the delivery (or directing or routing) was last tried, and when it
     should next be tried. More details about retry algorithms are given
     below.

  <LI> wait-smtp: This contains information about messages that are waiting for
     particular hosts after an SMTP delivery failure (see the next section).

  <LI> reject: This contains information about SMTP message rejections (see
     below).

</UL>
<P>
There is a utility program that lists the contents of one of these databases,
and another that allows manual modifications to be applied in some cases.
Database records are timestamped, and there is a utility that removes records
that are older than a given period, and also cleans up wait-smtp records
containing references to messages that no longer exist. Running this daily or
weekly should be sufficient to keep the files reasonably tidy.


<A NAME="12"><H2>14. SMTP batching</H2></A>

<P>
When an SMTP delivery attempt fails, causing the message to be deferred till
later, Exim updates a DBM database that contains records keyed by host name
plus IP address. Each record holds a list of messages that are waiting for
that host and address.

<P>
When an SMTP delivery succeeds, Exim consults the database to see if there are
any other messages waiting for the same host and address. If it finds any, it
creates a new Exim process and passes it the open SMTP channel and a message
identification. The new process then delivers the waiting message down the
existing channel and may in turn cause the creation of yet another process.
Any other waiting addresses in the message are skipped. The maximum number of
messages sent down one connection is configurable.

<P>
This scheme achieves some SMTP efficiency when a number of messages have been
queued up for a given host, without the overhead of a heavyweight queueing
apparatus.


<A NAME="13"><H2>15. Retries</H2></A>

<P>
When a message cannot immediately be directed, routed, or delivered, it
remains on the queue and another delivery attempt occurs at a later time.
While failures to deliver to remote hosts are the most common cause of this,
it is also possible for a message to be deferred as a result of temporary
local delivery failure, or following directing or routing. A local delivery
can fail if the user is over quota, while directing can be delayed if a user's
home directory is not available (e.g. missing NFS mount), and therefore the
existence of a .forward file cannot be tested. Routing can be delayed by DNS
timeouts.

<P>
Exim can be given a set of rules which specify how often to retry deferred
addresses, and when to give up. These rules apply to directing and routing as
well as to transporting, and are keyed by (wildcarded) domain name or, for
local users, by local-part and domain name, either of which can be wildcarded.

<P>
Each rule is actually a sequential list of subrules, which are applied
successively as time passes. At present there are two kinds of subrule: fixed
interval, and geometrically increasing interval. For example, it is possible
to specify a rule such as 'retry every 15 minutes for 2 hours; then increase
the interval between retries by a factor of 1.5 each time until 8 hours have
passed; then retry every 8 hours until 4 days have passed; then give up'. The
times are measured from when the address first failed, so, for example, if a
host has been down for 2 days, new messages will immediately go on to the
8-hour retry schedule.

<P>
Exim does not have an elaborate series of alarm clocks to cause retries to
happen exactly on schedule. A queue-runner process is started periodically, to
attempt delivery, one by one, of messages containing addresses that have
passed their next retry time. If such an address fails again, a new retry time
is computed, and so subsequent messages queued for the same address get
skipped. The queue is not processed sequentially, but in a 'random' order, to
prevent one rogue message that causes a problem blocking other messages to the
same destination for ever.

<P>
When the maximum time for retrying has passed, pending addresses are failed.
However, a next try time is still computed from the final subrule. Until that
time is reached, any new messages for the address are immediately failed. When
the next try time is passed, one further delivery attempt is made; if this
fails, a new next try time is computed, and so on.

<P>
The increasing number of small computers on the Internet has caused there to
be a lot of messages addressed to hosts that are never going to listen. The
retry logic described above should reduce the amount of wasted time spent on
trying to deliver such messages. However, some administrators are unhappy
about this rather draconian approach, which can cause an address to be failed
without any deliveries being attempted. Exim can alternatively be configured
always to try at least once those hosts whose last failure was before the
arrival of the message. This option increases the number of attempts to
deliver to dead hosts.

<P>
Retry rules can be predicated on particular errors as well as on domain names,
and for domains that are looked up in the DNS, further discrimination on
whether MX records were used or not is also possible. Thus it is possible to
treat 'connection refused' and 'connection timed out' differently, or to
distinguish between 'connection refused and there was only an A record' and
'connection refused from a host pointed to by an MX record'.

<P>
When a local delivery fails because a user is over quota, the retry rule can
be predicated on the length of time since the mailbox was last read. For
example, if the mailbox has been recently read, the delivery can be retried
for a while; otherwise it can be failed quickly.


<A NAME="14"><H2>16. Header rewriting</H2></A>

<P>
There are those who argue that header rewriting is a totally Bad Thing; there
are others who swear they cannot live without it. Exim provides the facility -
you do not have to use it!

<P>
Exim can be configured to rewrite the address portions of headers when a
message is received. For debugging purposes, the original headers are retained
in the spool file, but are not, of course, transported with the message.
Rewriting rules can be targeted at individual headers and the envelope fields;
it is possible, for example, just to rewrite the 'From' header and no others.

<P>
Rewriting rules are keyed by local-part and domain, either of which can be
wildcarded, and the replacement text is a general expansion string which can
contain file lookups. This makes it possible to replace login names by
'friendly' names in outgoing addresses via a DBM lookup, for example. The
other most common rewriting requirement of replacing *.foo.bar with foo.bar is
also easily handled.

<P>
Headers are also automatically rewritten by Exim in two cases:

<UL>
  <LI> If a locally-generated message contains addresses without domains, a
     configured qualifying domain is added to each of them. It is also
     possible to specify which remote systems are permitted to send messages
     containing unqualified addresses. These too get qualified on reception.

  <LI> Routing of a domain may reveal that is was only a partial domain, in
     which case the headers are rewritten to contain the full domain. For
     example, as a result of routing, an address such as xxx@foo may turn into
     xxx@foo.bar.ac.uk.


<A NAME="15"><H2>17. Host verification</H2></A>

</UL>
<P>
Exim can be configured to accept incoming SMTP calls from certain hosts only,
or it can be configured to reject calls from certain hosts. In both cases, the
test may include an RFC 1413 identification check. A system that gets all its
mail via a central hub might want to lock out the rest of the world, while a
number of systems under one management might want to exchange mail only via
the standard mailer, and hence reject mail from all but certain specified ids
within the group.

<P>
When a host fails the acceptance test, Exim can either give an error code
immediately on connection, or allow the connection to proceed and then give
error codes to all the message's recipients. The latter approach is useful
when using the mechanism to reject unsolicited junk mail and mail bombs,
because it normally prevents the sender from trying again with the same
message.


<A NAME="16"><H2>18. SMTP port reservation</H2></A>

<P>
The maximum number of simultaneous incoming SMTP calls can be set, and in
addition, a number of them can be reserved for particular hosts or particular
IP networks. It is also possible to specify a system load value above which
only calls from the reserved hosts are accepted.


<A NAME="17"><H2>19. Control of relaying</H2></A>

<P>
A host is said to act as a relay if it accepts an incoming message from an
external host and delivers it to an external host. Unscrupulous persons have
been known to use unsuspecting hosts as relays in an attempt to disguise the
origin of messages. An Exim host can be configured to accept mail from any
host for onward transmission to a specified set of domains only, and to accept
mail only from a specified list of hosts or networks for onward transmission
to any domain.


<A NAME="18"><H2>20. Sender verification</H2></A>

<P>
The return path of a message (also known as the 'envelope sender') is used
when Exim has to return an error message. If this is a bad address, the error
message cannot be delivered, and the postmaster has to sort things out.

<P>
Sender verification (a configurable option that applies to SMTP input) is
intended to pass this work to a foreign postmaster, by refusing to accept the
message in the first place. There is an exception list which can specify
certain hosts (with optional RFC 1413 identifications) that are allowed to
bypass the check.

<P>
There are two main causes of bad return paths: misconfigured mailers (gateways
in particular), and users fooling around with mail. Sadly, the latter are
rather common in educational institutions. Sender verification catches both of
them. It operates by passing the sender address through the directors and
routers in verification mode; if this fails, the message is not accepted.

<P>
The first thing foreign postmasters ask when they learn about a rejected
message is 'What were the headers?'. For this reason, and also to collect
evidence in cases of mail forgery, Exim does not initially reject a message
after the MAIL FROM command in the SMTP session. It reads the message, so as
to be able to write the headers to the rejection log, and then gives a hard
error response to the sending host.

<P>
Unfortunately, several mailers believe that any error response after the data
for a message has been sent indicates a temporary error. Consequently, such
mailers will continue to try to send a message that has been rejected as
described above. To prevent this, whenever a message is rejected, Exim records
the time, bad address, and host in a DBM database. If the same host sends the
same bad address within 24 hours, it is rejected immediately at the MAIL FROM
command.

<P>
Sadly, even this doesn't stop some mailers from repeatedly trying to send the
message. As a last resort, if the same host sends the same bad address for a
third time in 24 hours, the MAIL FROM command is accepted, but all subsequent
RCPT TO commands are rejected. If this does not stop a remote mailer then it
is badly broken.

<P>
If the attempt to verify the sender address cannot be completed (typically
because of a DNS timeout) Exim gives temporary error code to the MAIL FROM
command, which should cause the remote mailer to try again later. However, it
is possible to configure Exim to accept the message in these circumstances.

<P>
Many messages with bad return paths in fact contain perfectly valid 'From' or
'Reply-to' headers. For administrators that want a quieter life, there is a
configuration option which causes Exim to check these headers if the return
path is bad, and if a good address is found, to use it to replace the return
path. The old value is retained in an X- header.


<A NAME="19"><H2>21. Sender lock out</H2></A>

<P>
More and more unsolicited junk mail is being seen on the Internet. It is
sometimes useful to be able to reject messages (from any host) with particular
sender addresses in the envelope. Exim can be configured to reject messages
whose sender addresses match certain patterns, either by failing the MAIL FROM
command, or (because some mailers take no notice of that) by failing all RCPT
TO commands.


<A NAME="20"><H2>22. Receiver verification</H2></A>

<P>
Exim can be configured so that it checks the addresses given in incoming SMTP
RCPT TO commands as they are received. A failing address can be immediately
rejected, or it can be logged and accepted. If verification cannot be
completed (typically because of a DNS timeout) either a temporary error code
can be given, or the address can be logged and accepted.


<A NAME="21"><H2>23. The 'percent hack'</H2></A>

<P>
The so-called 'percent hack' is the feature of mailers whereby a local-part
containing a percent sign gets interpreted as an entire new address, with the
percent replaced by @. This is used for explicit mail routing and sometimes
for testing. In Exim, it is possible to configure which local domains, if any,
allow the 'percent hack'.


<A NAME="22"><H2>24. Security</H2></A>

<P>
Exim is written as a single binary that has to run setuid to root. I did start
off trying to write it as a number of different modules, but soon came to the
conclusion that, for this type of mailer, it was not worth it, because the
functions don't decompose cleanly. For example, if you want to verify
addresses while receiving mail you need all the directing and routing
apparatus to be available.

<P>
Exim runs each local delivery in a separate process which is setuid to the
relevant local user. In addition, it can be configured to run under a given
non-root uid (and gid) for much of the rest of the time. In particular, it
need not be root while sending or receiving SMTP mail. On systems that do not
have the seteuid function, it uses setuid to give up root, which requires it
to re-invoke itself in order to regain the privilege when it needs to deliver
a message. On systems that do have seteuid, it can be configured to use that
function instead, thereby saving some resources.

<P>
Exim can be configured to use seteuid (on systems that have it) when reading a
.forward file in a user's home directory. This is necessary when home
directories are NFS mounted without root privilege, unless .forward files are
required to be world readable.

<P>
Exim checks the permissions and owners of files to which messages are to be
appended, and refuses to proceed with the delivery if things are not right.

<P>
Delivery of messages to pipes or files is supported only as a result of
expanding an address via an alias or a forward file, provided this is
permitted by the configuration. Externally generated local addresses cannot
specify files or pipes - no special action is taken for addresses starting
with the file or pipe characters, so they will usually fail.

<P>
Use of the VRFY function in SMTP connections is controlled by a configuration
option. The EXPN and DEBUG functions are not supported at all.


<A NAME="23"><H2>25. The Exim Monitor</H2></A>

<P>
A program for monitoring Exim and displaying information in an X window is
provided. This can be configured to show stripcharts of incoming and outgoing
mail in various categories. It also shows a 'tail' of the main log file, and
information about messages on the queue.

<P>
There is a menu of operations that can be performed by suitably privileged
users. Messages can be frozen, thawed, deleted, caused to be delivered,
modified, or returned to their senders from this interface.

    <hr>
    <address><a href="mailto:Postmaster@exim.org">Nigel Metheringham</a></address>
<!-- Created: Sun May 16 21:43:01 BST 1999 -->
    <h6>$Cambridge$</h6>

</BODY>
</HTML>
